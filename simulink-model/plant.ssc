component plant
%Plant of quadrocopter

inputs
   ctrl={[0;0;0;0],'N'}; %Thrust:left
end

outputs
    pos={[0;0;0],'m'}; %Position:right
    v = {[0;0;0], 'm/s' }; %Velocity:right
    a = {[0;0;0], 'm/s^2' }; %Acceleration:right
    
    angle = {[0;0;0],'rad'};%Angle:right
    w = {[0;0;0],'rad/s'};%Angular velocity:right
end

parameters
    m = {0.027,'kg'};%Mass
    g = {9.81,'m/s^2'};%Gravity
    d = {0.046,'m'};%Arm length
    lift = {1.9796e-9,'m*kg'};%Lift constant
    drag = {2.5383e-11,'m^2*kg'};%Drag constant
end

parameters(Access=private)    
    %Moment of inertia matrix
    Jx = {1.1463e-5,'kg*m^2'};
    Jy = {1.6993e-5,'kg*m^2'};
    Jz = {2.9944e-5,'kg*m^2'};
    J = [Jx,0,0;0,Jy,0;0,0,Jz];

    % Add time invariant parameters here 

end

variables(Access=private)
    
    % Add time variant variables here
    
    % torques
    tau_x = { 0, 'N*m' };
    tau_y = { 0, 'N*m' };
    tau_z = { 0, 'N*m' };
    tau = { zeros(3,1), 'N*m' };
    
    % transformation matrix for expressing angular velocity in
    % time derivatives of Euler angles
    R_wa = { zeros(3,3), '1' };
    
    % transformation matrix from body to inertial frame
    R_ib = { zeros(3,3), '1' };
    
end

equations

    % Add all equations here 
    
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % REPLACE/REMOVE ALL THESE EQUATIONS
%     pos == {[0;0;0],'m'};
%     v == {[0;0;0], 'm/s' };
%     a == {[0;0;0], 'm/s^2' };
%     angle == {[0;0;0],'rad'};
%     w == {[0;0;0],'rad/s'};
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    
    % torques (ctrl = thrust, b = lift, k = drag) 
    tau_x == (sqrt(2)/2) * d * (ctrl(4) - ctrl(2) - ctrl(1) + ctrl(3));
    tau_y == (sqrt(2)/2) * d * (ctrl(2) - ctrl(4) + ctrl(3) - ctrl(1));
    tau_z == (drag/lift) * (-ctrl(1) - ctrl(3) + ctrl(2) + ctrl(4));
    % tau_z == (drag/lift);
    
    % torque vector
    tau == [tau_x;
            tau_y;
            tau_z];
        
    % relationships connected to time derivatives
    
    % translational
    v == pos.der;
    a == v.der;
    
    % rotational
    R_wa == [1 0 -sin(angle(2));
            0 cos(angle(1)) sin(angle(1))*cos(angle(2));
            0 -sin(angle(1)) cos(angle(1))*cos(angle(2))];
    w == R_wa*angle.der;
    
    % Newton-Euler equations
    R_ib == [cos(angle(2))*cos(angle(3)) sin(angle(1))*sin(angle(2))*cos(angle(3))-cos(angle(1))*sin(angle(3)) cos(angle(1))*sin(angle(2))*cos(angle(3))+sin(angle(1))*sin(angle(3));
             cos(angle(2))*sin(angle(3)) sin(angle(1))*sin(angle(2))*sin(angle(3))+cos(angle(1))*cos(angle(3)) cos(angle(1))*sin(angle(2))*sin(angle(3))-sin(angle(1))*cos(angle(3));
             -sin(angle(2))              sin(angle(1))*cos(angle(2))                                           cos(angle(1))*cos(angle(2))];
             
    m*a == -[0; 0; m*g] + R_ib*[0; 0; ctrl(1)+ctrl(2)+ctrl(3)+ctrl(4)];
    J*w.der == -cross(w,J*w) + tau;
    
end
end